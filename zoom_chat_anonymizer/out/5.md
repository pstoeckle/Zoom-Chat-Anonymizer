**14:10:56**, *Student 0*: Hey I have a quick question: do you know the date of the exam yet? And if not, do you when it will be announced? Thank you in advance

**14:11:12**, *Student 1*: ok here is our new interaction feature. If you want to ask a question on the Audio channel rather than ask it in written form and have Patrick respond to it in written or Maybe me in spoken form at the end of a 45 minutes block, please pose the Question in the Chat with a "#interactive: " tag. If you ask "#interactive: stack Frame", Patrick will ask me if I can respond to the Question directly, and give you the possibility to use your mic. Let's see if and how this works out.

**14:11:49**, *Student 1*: Re exam, well what do you think … at present, we do not know (nobody knows). We are discussing various Options as to how to do th exams. We'll Keep you posted.

**14:15:55**, *Student 2*: sec eng too

**14:17:42**, *Student 3*: quick temporary fix: Change the Settings in your  calendar to Show deleted Events. works just fine till it's fixed properly

**15:16:57**, *Student 3*: but wouldn't a Array be stored on the heap? That's why one should always clean the Memory afterwards. Am i missing something?

**15:17:57**, *Student 4*: namebuf is a fixed-size array (of length 10), so it ends up on the stack

**15:18:20**, *Student 5*: how about argv?

**15:18:39**, *Student 6*: Generally you only get allocations on the stack when you call malloc() or calloc() in C.

**15:18:52**, *Student 6*: *heap sorry

**15:19:31**, *Student 4*: argv is a pointer (which is again fixed size) to the arguments. These are then probably stored on heap

**15:23:38**, *Student 7*: [https://stackoverflow.com/questions/18681078/in-which-memory-segment-command-line-arguments-get-stored](https://stackoverflow.com/questions/18681078/in-which-memory-segment-command-line-arguments-get-stored)

**15:24:01**, *Student 7*: states stack in one of the experiments conducted

**15:24:48**, *Student 4*: Thanks!

**15:24:55**, *Patrick Stöckle*: @Student 3: As @Student 4 + Student 6: have already described: namebuf is on the stack. If you call `malloc`, e.g., with `int* namebuf = malloc(sizeof(int) * 10);` then you will have an array on the head, with the *pointer* of namebuf pointing to this array on the heap.

**15:25:34**, *Student 3*: alright, thanks for Clearing that up @everyone:)

**15:40:06**, *Student 8*: If there are safer functions available, such as strncpy, why would you not always use them? Or rather: Why wasn't strcpy reimplemented with this basic check? Is there a performance disadvantage?

**15:40:16**, *Student 6*: Fun fact from the gets() manpage: "Never use this function."

**15:43:05**, *Student 6*: The safer variants of the functions also often require additional input from the programmer. E.g. strncpy() introduces an additional argument which is the number of bytes to copy. You can't change strcpy to have this check because you would also need to introduce this additional argument which would break old C code that uses it.

**15:43:41**, *Student 9*: does aslr/kaslr is enough for securing addresses? the meltdown claims to find the kernel in at most 128 steps

**15:46:57**, *Student 6*: ASLR has limitations. If you can exploit a bug in the program so that you can get the value of a pointer (=> some memory address) you can find out which randomized address has been chosen for e.g. the stack base address, the heap base address.

**15:48:20**, *Student 3*: you could also search for certain Byte Patterns used near your address and basically create a signature of the area you're Looking for. If you find the signature, you find the address :D

